@namespace Dashboard
@using Microsoft.AspNetCore.Components.Routing
@using Microsoft.AspNetCore.Components.Web

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <base href="/" />
    <title>Stephens' Dashboard V1.3</title>
    <link rel="icon" href="/images/dashboard.png" />
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        * { transition: color 0.2s ease-in-out, background-color 0.2s ease-in-out, transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out; }
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: #111827; }
        ::-webkit-scrollbar-thumb { background: #4B5563; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #6B7280; }
        html { font-family: 'Inter', sans-serif; }
    </style>
    <HeadOutlet @rendermode="@(new Microsoft.AspNetCore.Components.Web.InteractiveServerRenderMode(prerender: false))" />
</head>
<body class="bg-gray-900 text-white min-h-screen font-sans">
    <Routes @rendermode="@(new Microsoft.AspNetCore.Components.Web.InteractiveServerRenderMode(prerender: false))" />

    <script src="_framework/blazor.web.js" autostart="false"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-chart-treemap@3.0.0/dist/chartjs-chart-treemap.min.js"></script>
    
    <script>
        Blazor.start({
            circuit: {
                reconnectionHandler: {
                    onConnectionDown: (options, error) => { window.location.reload(); }
                }
            }
        });
    </script>

    <script>
        window.startLocalClock = function() {
            function update() {
                const el = document.getElementById('local-clock');
                if (el) {
                    const now = new Date();
                    el.innerText = now.toLocaleDateString() + ' ' + now.toLocaleTimeString([], { hour: 'numeric', minute: '2-digit' }).toLowerCase();
                }
            }
            setInterval(update, 1000); 
            update(); 
        };

    window.renderBudgetTreemap = (canvasId, rawJsonData) => {
        const tryDrawing = () => {
            const ctx = document.getElementById(canvasId);
            if (!ctx) return false;

            const existingChart = Chart.getChart(canvasId);
            if (existingChart) existingChart.destroy();

            try {
                const chartData = JSON.parse(rawJsonData);
                new Chart(ctx, {
                    type: 'treemap',
                    data: {
                        datasets: [{
                            tree: chartData,
                            key: 'v',
                            spacing: 1,
                            borderWidth: (context) => (context.raw && context.raw.isForecast) ? 1 : 2,
                            borderColor: 'rgba(0,0,0,0.5)',
                            backgroundColor: (context) => {
                                if (!context.raw) return '#4B5563';
                                const d = context.raw._data || context.raw;
                                
                                // Base Colors
                                let color = '#10B981'; // Default Green
                                if (d.l === 'Unaccounted') color = '#3B82F6';
                                else if (parseFloat(d.r) < -0.01) color = '#EF4444';
                                else if (Math.abs(parseFloat(d.r)) < 0.01) color = '#FACC15';

                                // If it's a forecast item, make it semi-transparent "Shadow"
                                return d.isForecast ? color + '44' : color; 
                            },
                            labels: {
                                display: true,
                                formatter: (context) => {
                                    const d = context.raw._data || context.raw;
                                    const prefix = d.isForecast ? "ðŸ•’ " : "";
                                    return d.v > 40 ? [prefix + d.l, `$${Math.round(d.v)}`] : [];
                                },
                                font: { size: 10, weight: 'bold' },
                                color: (context) => {
                                    const d = context.raw._data || context.raw;
                                    if (d.isForecast) return '#9CA3AF'; // Muted gray text for shadows
                                    return (Math.abs(parseFloat(d.r)) < 0.01 && d.l !== 'Unaccounted') ? '#1F2937' : 'white';
                                }
                            }
                        }]
                    },
                    options: {
                        plugins: { 
                            legend: { display: false },
                            tooltip: {
                                callbacks: {
                                    title: (items) => {
                                        const d = items[0].raw._data || items[0].raw;
                                        return (d.isForecast ? "[FORECAST] " : "") + d.l;
                                    },
                                    label: (item) => {
                                        const d = item.raw._data || item.raw;
                                        const rem = parseFloat(d.r);
                                        const val = parseFloat(d.v);
                                        if (d.isForecast) return ` Expected Bill: $${val.toLocaleString()}`;
                                        
                                        let status = rem < -0.01 ? "Deficit" : (Math.abs(rem) < 0.01 ? "Balanced" : "Remaining");
                                        return [` Budget: $${val.toLocaleString()}`, ` ${status}: $${Math.abs(rem).toLocaleString()}`];
                                    }
                                }
                            }
                        },
                        maintainAspectRatio: false
                    }
                });
                return true;
            } catch (e) { console.error("Chart Error:", e); return true; }
        };

        if (!tryDrawing()) {
            const observer = new MutationObserver((mutations, obs) => {
                if (document.getElementById(canvasId)) { tryDrawing(); obs.disconnect(); }
            });
            observer.observe(document.body, { childList: true, subtree: true });
        }
    };
</script>
</body>
</html>